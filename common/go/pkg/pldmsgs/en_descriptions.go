// Copyright Â© 2024 Kaleido, Inc.
//
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pldmsgs

import (
	"github.com/kaleido-io/paladin/common/go/pkg/i18n"
	"golang.org/x/text/language"
)

//revive:disable
var pdm = func(key, translation string) i18n.MessageKey {
	return i18n.PDM(language.AmericanEnglish, key, translation)
}

// pldapi/blockindex.go
var (
	IndexedBlockNumber                 = pdm("IndexedBlock.number", "The block number")
	IndexedBlockHash                   = pdm("IndexedBlock.hash", "The unique hash of the block")
	IndexedBlockTimestamp              = pdm("IndexedBlock.timestamp", "The block timestamp")
	IndexedTransactionHash             = pdm("IndexedTransaction.hash", "The unique hash of the transaction")
	IndexedTransactionBlockNumber      = pdm("IndexedTransaction.blockNumber", "The block number containing this transaction")
	IndexedTransactionTransactionIndex = pdm("IndexedTransaction.transactionIndex", "The index of the transaction within the block")
	IndexedTransactionFrom             = pdm("IndexedTransaction.from", "The sender's Ethereum address")
	IndexedTransactionTo               = pdm("IndexedTransaction.to", "The recipient's Ethereum address (optional)")
	IndexedTransactionNonce            = pdm("IndexedTransaction.nonce", "The transaction nonce")
	IndexedTransactionContractAddress  = pdm("IndexedTransaction.contractAddress", "The contract address created by this transaction (optional)")
	IndexedTransactionResult           = pdm("IndexedTransaction.result", "The result of the transaction (optional)")
	IndexedTransactionBlock            = pdm("IndexedTransaction.block", "The block containing this event")
	IndexedEventBlockNumber            = pdm("IndexedEvent.blockNumber", "The block number containing this event")
	IndexedEventTransactionIndex       = pdm("IndexedEvent.transactionIndex", "The index of the transaction within the block")
	IndexedEventLogIndex               = pdm("IndexedEvent.logIndex", "The log index of the event")
	IndexedEventTransactionHash        = pdm("IndexedEvent.transactionHash", "The hash of the transaction that triggered this event")
	IndexedEventSignature              = pdm("IndexedEvent.signature", "The event signature")
	IndexedEventTransaction            = pdm("IndexedEvent.transaction", "The transaction that triggered this event (optional)")
	IndexedEventBlock                  = pdm("IndexedEvent.block", "The block containing this event")
	EventWithDataSoliditySignature     = pdm("EventWithData.soliditySignature", "A Solidity style description of the event and parameters, including parameter names and whether they are indexed")
	EventWithDataAddress               = pdm("EventWithData.address", "The address of the smart contract that emitted this event")
	EventWithDataData                  = pdm("EventWithData.data", "JSON formatted data from the event")
)

// pldapi/keymgr.go
var (
	WalletInfoName                     = pdm("WalletInfo.name", "The name of the wallet")
	WalletInfoKeySelector              = pdm("WalletInfo.keySelector", "The key selector for the wallet")
	KeyMappingIdentifier               = pdm("KeyMapping.identifier", "The full identifier used to look up this key")
	KeyMappingWallet                   = pdm("KeyMapping.wallet", "The name of the wallet containing this key")
	KeyMappingKeyHandle                = pdm("KeyMapping.keyHandle", "The handle within the wallet containing the key")
	KeyMappingWithPathPath             = pdm("KeyMappingWithPath.path", "The full path including the leaf that is the identifier")
	KeyMappingAndVerifierVerifier      = pdm("KeyMappingAndVerifier.verifier", "The verifier associated with this key mapping")
	KeyVerifierWithKeyRefKeyIdentifier = pdm("KeyVerifierWithKeyRef.keyIdentifier", "The identifier of the key associated with this verifier")
	KeyVerifierVerifier                = pdm("KeyVerifier.verifier", "The verifier value")
	KeyVerifierType                    = pdm("KeyVerifier.type", "The type of verifier")
	KeyVerifierAlgorithm               = pdm("KeyVerifier.algorithm", "The algorithm used by the verifier")
	KeyPathSegmentName                 = pdm("KeyPathSegment.name", "The name of the path segment")
	KeyPathSegmentIndex                = pdm("KeyPathSegment.index", "The index of the path segment")
)

// pldapi/public_tx.go
var (
	PublicTxOptionsGas                     = pdm("PublicTxOptions.gas", "The gas limit for the transaction (optional)")
	PublicTxOptionsValue                   = pdm("PublicTxOptions.value", "The value transferred in the transaction (optional)")
	PublicCallOptionsBlock                 = pdm("PublicCallOptions.block", "The block number or 'latest' when calling a public smart contract (optional)")
	PublicTxGasPricingMaxPriorityFeePerGas = pdm("PublicTxGasPricing.maxPriorityFeePerGas", "The maximum priority fee per gas (optional)")
	PublicTxGasPricingMaxFeePerGas         = pdm("PublicTxGasPricing.maxFeePerGas", "The maximum fee per gas (optional)")
	PublicTxGasPricingGasPrice             = pdm("PublicTxGasPricing.gasPrice", "The gas price (optional)")
	PublicTxInputFrom                      = pdm("PublicTxInput.from", "The resolved signing account")
	PublicTxInputTo                        = pdm("PublicTxInput.to", "The target contract address (optional)")
	PublicTxInputData                      = pdm("PublicTxInput.data", "The pre-encoded calldata (optional)")
	PublicTxSubmissionFrom                 = pdm("PublicTxSubmission.from", "The sender's Ethereum address")
	PublicTxSubmissionNonce                = pdm("PublicTxSubmission.nonce", "The transaction nonce")
	PublicTxSubmissionDataTime             = pdm("PublicTxSubmissionData.time", "The submission time")
	PublicTxSubmissionDataTransactionHash  = pdm("PublicTxSubmissionData.transactionHash", "The transaction hash")
	PublicTxLocalID                        = pdm("PublicTx.localId", "A locally generated numeric ID for the public transaction. Unique within the node")
	PublicTxTo                             = pdm("PublicTx.to", "The target contract address (optional)")
	PublicTxData                           = pdm("PublicTx.data", "The pre-encoded calldata (optional)")
	PublicTxFrom                           = pdm("PublicTx.from", "The sender's Ethereum address")
	PublicTxNonce                          = pdm("PublicTx.nonce", "The transaction nonce")
	PublicTxCreated                        = pdm("PublicTx.created", "The creation time")
	PublicTxCompletedAt                    = pdm("PublicTx.completedAt", "The completion time (optional)")
	PublicTxTransactionHash                = pdm("PublicTx.transactionHash", "The transaction hash (optional)")
	PublicTxSuccess                        = pdm("PublicTx.success", "The transaction success status (optional)")
	PublicTxRevertData                     = pdm("PublicTx.revertData", "The revert data (optional)")
	PublicTxSubmissions                    = pdm("PublicTx.submissions", "The submission data (optional)")
	PublicTxActivity                       = pdm("PublicTx.activity", "The transaction activity records (optional)")
	PublicTxBindingTransaction             = pdm("PublicTxBinding.transaction", "The transaction ID")
	PublicTxBindingTransactionType         = pdm("PublicTxBinding.transactionType", "The transaction type")
)

// pldapi/stored_abi.go
var (
	StoredABIHash = pdm("StoredABI.hash", "The unique hash of the ABI")
	StoredABIAPI  = pdm("StoredABI.abi", "The Application Binary Interface (ABI) definition")
)

// pldclient/transaction.go
var (
	TransactionID                                           = pdm("Transaction.id", "Server-generated UUID for this transaction (query only)")
	TransactionCreated                                      = pdm("Transaction.created", "Server-generated creation timestamp for this transaction (query only)")
	TransactionSubmitMode                                   = pdm("Transaction.submitMode", "Whether the submission of the transaction to the base ledger is to be performed automatically by the node or coordinated externally (query only)")
	TransactionIdempotencyKey                               = pdm("Transaction.idempotencyKey", "Externally supplied unique identifier for this transaction. 409 Conflict will be returned on attempt to re-submit")
	TransactionType                                         = pdm("Transaction.type", "Type of transaction (public or private)")
	TransactionDomain                                       = pdm("Transaction.domain", "Name of a domain - only required on input for private deploy transactions")
	TransactionFunction                                     = pdm("Transaction.function", "Function signature - inferred from definition if not supplied")
	TransactionABIReference                                 = pdm("Transaction.abiReference", "Calculated ABI reference - required with ABI on input if not constructor")
	TransactionFrom                                         = pdm("Transaction.from", "Locator for a local signing identity to use for submission of this transaction. May be a key identifier, or an eth address prefixed with 'verifier:'.")
	TransactionTo                                           = pdm("Transaction.to", "Target contract address, or null for a deploy")
	TransactionData                                         = pdm("Transaction.data", "Pre-encoded array with/without function selector, array, or object input")
	TransactionInputDependsOn                               = pdm("TransactionInput.dependsOn", "Transactions that must be mined on the blockchain successfully before this transaction submits")
	TransactionInputABI                                     = pdm("TransactionInput.abi", "Application Binary Interface (ABI) definition - required if abiReference not supplied")
	TransactionInputBytecode                                = pdm("TransactionInput.bytecode", "Bytecode prepended to encoded data inputs for deploy transactions")
	TransactionCallDataFormat                               = pdm("TransactionCall.dataFormat", "How call data should be serialized into JSON once decoded using the ABI function definition")
	TransactionFullDependsOn                                = pdm("TransactionFull.dependsOn", "Transactions registered as dependencies when the transaction was created")
	TransactionFullReceipt                                  = pdm("TransactionFull.receipt", "Transaction receipt data - available if the transaction has reached a final state")
	TransactionFullPublic                                   = pdm("TransactionFull.public", "List of public transactions associated with this transaction")
	TransactionFullHistory                                  = pdm("TransactionFull.history", "List of values that have previously been provided for this transaction")
	TransactionReceiptID                                    = pdm("TransactionReceipt.id", "Transaction ID")
	TransactionReceiptDataOnchainTransactionHash            = pdm("TransactionReceiptDataOnchain.transactionHash", "Transaction hash")
	TransactionReceiptDataOnchainBlockNumber                = pdm("TransactionReceiptDataOnchain.blockNumber", "Block number")
	TransactionReceiptDataOnchainTransactionIndex           = pdm("TransactionReceiptDataOnchain.transactionIndex", "Transaction index")
	TransactionReceiptDataOnchainEventLogIndex              = pdm("TransactionReceiptDataOnchainEvent.logIndex", "Log index")
	TransactionReceiptDataOnchainEventSource                = pdm("TransactionReceiptDataOnchainEvent.source", "Event source")
	TransactionReceiptDataIndexed                           = pdm("TransactionReceiptData.indexed", "The time when this receipt was indexed by the node, providing a relative order of transaction receipts within this node (might be significantly after the timestamp of the block)")
	TransactionReceiptDataSequence                          = pdm("TransactionReceiptData.sequence", "A local order of this receipt compared to other receipts on the node, used for ordering of receipts when delivering to receipt listeners")
	TransactionReceiptDataDomain                            = pdm("TransactionReceiptData.domain", "The domain that executed the transaction, for private transactions only")
	TransactionReceiptDataSuccess                           = pdm("TransactionReceiptData.success", "Transaction success status")
	TransactionReceiptDataFailureMessage                    = pdm("TransactionReceiptData.failureMessage", "Failure message - set if transaction reverted")
	TransactionReceiptDataRevertData                        = pdm("TransactionReceiptData.revertData", "Encoded revert data - if available")
	TransactionReceiptDataContractAddress                   = pdm("TransactionReceiptData.contractAddress", "New contract address - to be used in the 'To' field for subsequent invoke transactions")
	TransactionReceiptFullStates                            = pdm("TransactionReceiptFull.states", "The state receipt for the transaction (private transactions only)")
	TransactionReceiptFullDomainReceipt                     = pdm("TransactionReceiptFull.domainReceipt", "The domain receipt for the transaction (private transaction only)")
	TransactionReceiptFullDomainReceiptError                = pdm("TransactionReceiptFull.domainReceiptError", "Contains the error if it was not possible to obtain the domain receipt for a private transaction")
	TransactionActivityRecordTime                           = pdm("TransactionActivityRecord.time", "Time the record occurred")
	TransactionActivityRecordMessage                        = pdm("TransactionActivityRecord.message", "Activity message")
	TransactionDependenciesDependsOn                        = pdm("TransactionDependencies.dependsOn", "Transactions that this transaction depends on")
	TransactionDependenciesPrereqOf                         = pdm("TransactionDependencies.prereqOf", "Transactions that require this transaction as a prerequisite")
	PreparedTransactionID                                   = pdm("PreparedTransaction.id", "The ID of the original transaction that prepared this transaction, and will be confirmed by its submission to the blockchain")
	PreparedTransactionDomain                               = pdm("PreparedTransaction.domain", "The domain of the original transaction that prepared this transaction submission")
	PreparedTransactionTo                                   = pdm("PreparedTransaction.to", "The to address or the original transaction that prepared this transaction submission")
	PreparedTransactionTransaction                          = pdm("PreparedTransaction.transaction", "The Paladin transaction definition that has been prepared for submission, with the ABI and function details resolved")
	PreparedTransactionMetadata                             = pdm("PreparedTransaction.metadata", "Domain specific additional information generated during prepare in addition to the states. Used particularly in atomic multi-party transactions to separate data that can be disclosed, away from the full transaction submission payload")
	PreparedTransactionStates                               = pdm("PreparedTransaction.states", "Details of all states of the original transaction that prepared this transaction submission")
	DecodedErrorData                                        = pdm("ABIDecodedData.data", "The decoded JSON data using the matched ABI definition")
	DecodedSummary                                          = pdm("ABIDecodedData.summary", "A string formatted summary - errors only")
	DecodedDefinition                                       = pdm("ABIDecodedData.definition", "The ABI definition entry matched from the dictionary of ABIs")
	DecodedSignature                                        = pdm("ABIDecodedData.signature", "The signature of the matched ABI definition")
	TransactionReceiptListenerName                          = pdm("TransactionReceiptListener.name", "Unique name for the receipt listener")
	TransactionReceiptListenerCreated                       = pdm("TransactionReceiptListener.created", "Time the listener was created")
	TransactionReceiptListenerStarted                       = pdm("TransactionReceiptListener.started", "If the listener is started - can be set to false to disable delivery server-side")
	TransactionReceiptListenerFilters                       = pdm("TransactionReceiptListener.filters", "Filters to apply to receipts")
	TransactionReceiptListenerOptions                       = pdm("TransactionReceiptListener.options", "Options for the receipt listener")
	TransactionReceiptFiltersSequenceAbove                  = pdm("TransactionReceiptFilters.sequenceAbove", "Only deliver receipts above a certain sequence (rather than from the beginning of indexing of the chain)")
	TransactionReceiptFiltersType                           = pdm("TransactionReceiptFilters.type", "Only deliver receipts for one transaction type (public/private)")
	TransactionReceiptFiltersDomain                         = pdm("TransactionReceiptFilters.domain", "Only deliver receipts for an individual domain (only valid with type=private)")
	TransactionReceiptOptionsDomainReceipts                 = pdm("TransactionReceiptOptions.domainReceipts", "When true, a full domain receipt will be generated for each event with complete state data")
	TransactionReceiptOptionsIncompleteStateReceiptBehavior = pdm("TransactionReceiptOptions.incompleteStateReceiptBehavior", "When set to 'block_contract', if a transaction with incomplete state data is detected then delivery of all receipts on that individual smart contract address will pause until the missing state arrives. Receipts for other contract addresses continue to be delivered")
	BlockchainEventListenerName                             = pdm("BlockchainEventListener.name", "Unique name for the blockchain event listener")
	BlockchainEventListenerCreated                          = pdm("BlockchainEventListener.created", "Time the listener was created")
	BlockchainEventListenerStarted                          = pdm("BlockchainEventListener.started", "If the listener is started - can be set to false to disable delivery server-side")
	BlockchainEventListenerSources                          = pdm("BlockchainEventListener.sources", "Sources of events")
	BlockchainEventListenerOptions                          = pdm("BlockchainEventListener.options", "Options for the event listener")
	BlockchainEventListenerOptionsBatchSize                 = pdm("BlockchainEventListenerOptions.batchSize", "The maximum number of events to deliver in each batch")
	BlockchainEventListenerOptionsBatchTimeout              = pdm("BlockchainEventListenerOptions.batchTimeout", "The maximum time to wait for a batch to fill before delivering")
	BlockchainEventListenerOptionsFromBlock                 = pdm("BlockchainEventListenerOptions.fromBlock", "The block number from which to start listenening for events, or 'latest' to start from the latest block")
	BlockchainEventListenerSourceABI                        = pdm("BlockchainEventListenerSource.abi", "The ABI containing events to listen for")
	BlockchainEventListenerSourceAddress                    = pdm("BlockchainEventListenerSource.address", "The address to listen for events from")
	BlockchainEventListenerStatusCatchup                    = pdm("BlockchainEventListenerStatus.catchup", "Whether the event listener is catching up to the latest block")
	BlockcgainEventListenerStatusCheckpoint                 = pdm("BlockchainEventListenerStatus.checkpoint", "The checkpoint for the event listener")
	BlockchainEventListenerCheckpointBlockNumber            = pdm("BlockchainEventListenerCheckpoint.blockNumber", "The last block fully processed by the event listener")
)

// query/query_json.go
var (
	QueryJSONStatements         = pdm("QueryJSON.statements", "Query statements")
	QueryJSONLimit              = pdm("QueryJSON.limit", "Query limit")
	QueryJSONSort               = pdm("QueryJSON.sort", "Query sort order")
	FilterResultsWithCountCount = pdm("FilterResultsWithCount.count", "Number of items returned")
	FilterResultsWithCountTotal = pdm("FilterResultsWithCount.total", "Total number of items available")
	FilterResultsWithCountItems = pdm("FilterResultsWithCount.items", "Returned items")
	ItemsResultTypedCount       = pdm("ItemsResultTyped.count", "Number of items returned")
	ItemsResultTypedTotal       = pdm("ItemsResultTyped.total", "Total number of items available")
	ItemsResultTypedItems       = pdm("ItemsResultTyped.items", "Returned items")
	OpNot                       = pdm("Op.not", "Negate the operation")
	OpCaseInsensitive           = pdm("Op.caseInsensitive", "Perform case-insensitive matching")
	OpField                     = pdm("Op.field", "Field to apply the operation to")
	OpSingleValValue            = pdm("OpSingleVal.value", "Value to compare against")
	OpMultiValValues            = pdm("OpMultiVal.values", "Values to compare against")
	StatementsOr                = pdm("Statements.or", "List of alternative statements")
	OpsEqual                    = pdm("Ops.equal", "Equal to")
	OpsEq                       = pdm("Ops.eq", "Equal to (short name)")
	OpsNEq                      = pdm("Ops.neq", "Not equal to")
	OpsLike                     = pdm("Ops.like", "Like")
	OpsLessThan                 = pdm("Ops.lessThan", "Less than")
	OpsLT                       = pdm("Ops.lt", "Less than (short name)")
	OpsLessThanOrEqual          = pdm("Ops.lessThanOrEqual", "Less than or equal to")
	OpsLTE                      = pdm("Ops.lte", "Less than or equal to (short name)")
	OpsGreaterThan              = pdm("Ops.greaterThan", "Greater than")
	OpsGT                       = pdm("Ops.gt", "Greater than (short name)")
	OpsGreaterThanOrEqual       = pdm("Ops.greaterThanOrEqual", "Greater than or equal to")
	OpsGTE                      = pdm("Ops.gte", "Greater than or equal to (short name)")
	OpsIn                       = pdm("Ops.in", "In")
	OpsNIn                      = pdm("Ops.nin", "Not in")
	OpsNull                     = pdm("Ops.null", "Null")
)

// pldclient/states.go
var (
	StateID                      = pdm("State.id", "The ID of the state, which is generated from the content per the rules of the domain, and is unique within the contract")
	StateCreated                 = pdm("State.created", "Server-generated creation timestamp for this state (query only)")
	StateDomain                  = pdm("State.domain", "The name of the domain this state is managed by")
	StateSchema                  = pdm("State.schema", "The ID of the schema for this state, which defines what fields it has and which are indexed for query")
	StateContractAddress         = pdm("State.contractAddress", "The address of the contract that manages this state within the domain")
	StateData                    = pdm("State.data", "The JSON formatted data for this state")
	StateConfirmed               = pdm("State.confirmed", "The confirmation record, if this an on-chain confirmation has been indexed from the base ledger for this state")
	StateSpent                   = pdm("State.spent", "The spend record, if this an on-chain spend has been indexed from the base ledger for this state")
	StateRead                    = pdm("State.read", "Read record, only returned when querying within an in-memory domain context to represent read-lock on a state from a transaction in that domain context")
	StateLocks                   = pdm("State.locks", "When querying states within a domain context running ahead of the blockchain assembling transactions for submission, this provides detail on locks applied to the state")
	StateNullifier               = pdm("State.nullifier", "Only set if nullifiers are being used in the domain, and a nullifier has been generated that is available for spending this state")
	StateConfirmTransaction      = pdm("StateConfirm.transaction", "The ID of the Paladin transaction where this state was confirmed")
	StateSpendTransaction        = pdm("StateSpend.transaction", "The ID of the Paladin transaction where this state was spent")
	StateLockTransaction         = pdm("StateLock.transaction", "The ID of the Paladin transaction being assembled that is responsible for this lock")
	StateLockType                = pdm("StateLock.type", "Whether this lock is for create, read or spend")
	SchemaID                     = pdm("Schema.id", "The hash derived ID of the schema (query only)")
	SchemaCreated                = pdm("Schema.created", "Server-generated creation timestamp for this schema (query only)")
	SchemaDomain                 = pdm("Schema.domain", "The name of the domain this schema is managed by")
	SchemaSignature              = pdm("Schema.signature", "Human readable signature string for this schema, that is used to generate the hash")
	SchemaType                   = pdm("Schema.type", "The type of the schema, such as if it is an ABI defined schema")
	SchemaDefinition             = pdm("Schema.definition", "The definition of the schema, such as the ABI definition")
	SchemaLabels                 = pdm("Schema.labels", "The list of indexed labels that can be used to filter and sort states using to this schema")
	TransactionStatesNone        = pdm("TransactionStates.none", "No state reference records have been indexed for this transaction. Either the transaction has not been indexed, or it did not reference any states")
	TransactionStatesSpent       = pdm("TransactionStates.spent", "Private state data for input states that were spent in this transaction")
	TransactionStatesRead        = pdm("TransactionStates.read", "Private state data for states that were unspent and used during execution of this transaction, but were not spent by it")
	TransactionStatesConfirmed   = pdm("TransactionStates.confirmed", "Private state data for new states that were confirmed as new unspent states during this transaction")
	TransactionStatesInfo        = pdm("TransactionStates.info", "Private state data for states that were recorded as part of this transaction, and existed only as reference data during its execution. They were not validated as unspent during execution, or recorded as new unspent states")
	TransactionStatesUnavailable = pdm("TransactionStates.unavailable", "If present, this contains information about states recorded as used by this transactions when indexing, but for which the private data is unavailable on this node")
	UnavailableStatesSpent       = pdm("UnavailableStates.spent", "The IDs of spent states consumed by this transaction, for which the private data is unavailable")
	UnavailableStatesRead        = pdm("UnavailableStates.read", "The IDs of read states used by this transaction, for which the private data is unavailable")
	UnavailableStatesConfirmed   = pdm("UnavailableStates.confirmed", "The IDs of confirmed states created by this transaction, for which the private data is unavailable")
	UnavailableStatesInfo        = pdm("UnavailableStates.info", "The IDs of info states referenced in this transaction, for which the private data is unavailable")
)

// pldclient/registry.go
var (
	RegistryEntryRegistry                 = pdm("RegistryEntry.registry", "The registry that maintains this record")
	RegistryEntryID                       = pdm("RegistryEntry.id", "The ID of the entry, which is unique within the registry across all records in the hierarchy")
	RegistryEntryName                     = pdm("RegistryEntry.name", "The name of the entry, which is unique across entries with the same parent")
	RegistryParentID                      = pdm("RegistryEntry.parentId", "Unset for a root record, otherwise a reference to another entity in the same registry")
	RegistryEntryWithPropertiesProperties = pdm("RegistryEntryWithProperties.properties", "A name + value pair map of all the active properties for this entry. Only active properties are listed, even if the query on the entries used an activeFilter to return inactive entries")
	RegistryPropertyRegistry              = pdm("RegistryProperty.registry", "The registry that maintains this record")
	RegistryPropertyEntryID               = pdm("RegistryProperty.entryId", "The ID of the entry this property is associated with")
	RegistryPropertyName                  = pdm("RegistryProperty.name", "The name of the property")
	RegistryPropertyValue                 = pdm("RegistryProperty.value", "The value of the property")
	OnChainLocationBlockNumber            = pdm("OnChainLocation.blockNumber", "For Ethereum blockchain backed registries, this is the block number where the registry entry/property was set")
	OnChainLocationTransactionIndex       = pdm("OnChainLocation.transactionIndex", "The transaction index within the block")
	OnChainLocationLogIndex               = pdm("OnChainLocation.logIndex", "The log index within the transaction of the event")
	ActiveFlagActive                      = pdm("ActiveFlag.active", "When querying with an activeFilter of 'any' or 'inactive', this boolean shows if the entry/property is active or not")
)

// pldclient/transport.go
var (
	PeerInfoName              = pdm("PeerInfo.name", "The name of the peer node")
	PeerInfoStats             = pdm("PeerInfo.stats", "Statistics for the outbound and inbound data transfer")
	PeerInfoActivated         = pdm("PeerInfo.activated", "The time when the peer was activated by an attempt to send data, or data arriving on a transport from this peer")
	PeerInfoOutbound          = pdm("PeerInfo.outbound", "Transport specific information about an established outbound connection to the peer. Omitted if the peer does not have an established outbound connection")
	PeerInfoOutboundTransport = pdm("PeerInfo.outboundTransport", "The name of the transport selected for outbound connection to the peer. Omitted if no attempt to send data has occurred for this peer")
	PeerInfoOutboundError     = pdm("PeerInfo.outboundError", "Contains an error if attempting to send data, and the transport connection failed")

	PeerStatsSentMsgs            = pdm("PeerStats.sentMsgs", "Count of messages sent since activation of this peer")
	PeerStatsReceivedMsgs        = pdm("PeerStats.receivedMsgs", "Count of messages received since activation of this peer")
	PeerStatsSentBytes           = pdm("PeerStats.sentBytes", "Count of payload bytes sent since activation of this peer (does not include header data)")
	PeerStatsReceivedBytes       = pdm("PeerStats.receivedBytes", "Count of payload bytes received since activation of this peer (does not include header data)")
	PeerStatsLastSend            = pdm("PeerStats.lastSend", "Timestamp of the last send to this peer")
	PeerStatsLastReceive         = pdm("PeerStats.lastReceive", "Timestamp of the last receive from this peer")
	PeerStatsReliableHighestSent = pdm("PeerStats.reliableHighestSent", "Outbound reliable messages are assigned a sequence. This is the highest sequence sent to the peer since activation")
	PeerStatsReliableAckBase     = pdm("PeerStats.reliableAckBase", "Outbound reliable messages are assigned a sequence. This is the lowest sequence that has not received an acknowledgement from the peer")

	ReliableMessageSequence    = pdm("ReliableMessage.sequence", "Sequence number for the position of this message in the local database")
	ReliableMessageID          = pdm("ReliableMessage.id", "UUID for this message. A separate message, with a separate ID, is allocated for each participant that will receive the message")
	ReliableMessageCreated     = pdm("ReliableMessage.created", "The time this message was created")
	ReliableMessageNode        = pdm("ReliableMessage.node", "The target node for this message to be delivered to")
	ReliableMessageMessageType = pdm("ReliableMessage.messageType", "The type of the message. Each type has a different locally stored metadata schema, and an on-the-wire full payload format that can be built from the metadata on the source node")
	ReliableMessageMetadata    = pdm("ReliableMessage.metadata", "The locally stored (on the source node) minimal data that allows the on-the-wire message to be built using other stored data")
	ReliableMessageAck         = pdm("ReliableMessage.ack", "An ack (or nack with error) that has finalized this message delivery so it will not be retried")

	ReliableMessageAckMessageID    = pdm("ReliableMessageAck.messageId", "ID of the reliable message delivery that this ack is associated with")
	ReliableMessageAckMessageTime  = pdm("ReliableMessageAck.time", "Time the ack was received (or generated if it is local failure that stops a delivery being attempted)")
	ReliableMessageAckMessageError = pdm("ReliableMessageAck.error", "A permanent failure (a 'nack') that will stop any further attempts to deliver this message")
)

// pldclient/privacygroups.go
var (
	PrivacyGroupEVMCallDomain        = pdm("PrivacyGroupEVMTX.domain", "The domain that manages the privacy group")
	PrivacyGroupEVMCallGroup         = pdm("PrivacyGroupEVMTX.group", "The privacy group ID")
	PrivacyGroupEVMTXFrom            = pdm("PrivacyGroupEVMTX.from", "The local signing identity to use to submit the transaction")
	PrivacyGroupEVMTXTo              = pdm("PrivacyGroupEVMTX.to", "The private EVM smart contract address to invoke, or null for an EVM smart contract deployment")
	PrivacyGroupEVMTXGas             = pdm("PrivacyGroupEVMTX.gas", "Gas limit for the transaction (optional)")
	PrivacyGroupEVMTXValue           = pdm("PrivacyGroupEVMTX.value", "Native gas token value to transfer in the transaction, if supported by the EVM privacy group domain (optional)")
	PrivacyGroupEVMTXInput           = pdm("PrivacyGroupEVMTX.input", "An object or array of unencoded inputs, when an function ABI is supplied. Or a hex string containing pre-encoded function selector and ABI encoded inputs")
	PrivacyGroupEVMTXFunction        = pdm("PrivacyGroupEVMTX.function", "The ABI fragment/entry for the function to call. Do not supply the whole ABI array, just one object for the function/constructor. Omit when pre-encoded hex input is provided")
	PrivacyGroupEVMTXBytecode        = pdm("PrivacyGroupEVMTX.bytecode", "For contract deployments to EVM privacy groups, the bytecode must be submitted separately to the constructor parameters (which are supplied as input)")
	PrivacyGroupEVMTXIdempotencyKey  = pdm("PrivacyGroupEVMTX.idempotencyKey", "The idempotencyKey to use in the resulting transaction submission")
	PrivacyGroupEVMTXPublicTxOptions = pdm("PrivacyGroupEVMTX.publicTxOptions", "The public transaction submission options to use in the resulting transaction submission")

	PrivacyGroupInputTransactionOptions = pdm("PrivacyGroupInput.transactionOptions", "Options that will be propagated to the final private transaction that is submitted after the domain has validated the input properties and generated the base private transaction")

	PrivacyGroupID                 = pdm("PrivacyGroup.id", "The ID of the group, which is the hash-derived ID of the genesis state (assured to be unique within the domain)")
	PrivacyGroupDomain             = pdm("PrivacyGroup.domain", "The domain of the privacy group")
	PrivacyGroupCreated            = pdm("PrivacyGroup.created", "The creation time")
	PrivacyGroupName               = pdm("PrivacyGroup.name", "Optional name for the privacy group, which is indexed for efficient query")
	PrivacyGroupProperties         = pdm("PrivacyGroup.properties", "Application specific properties for the privacy group")
	PrivacyGroupConfiguration      = pdm("PrivacyGroup.configuration", "Domain specific configuration options that define the behavior of the privacy group")
	PrivacyGroupMembers            = pdm("PrivacyGroup.members", "The member list must be a set of fully qualified identity locators 'some.identity@node.name'")
	PrivacyGroupContractAddress    = pdm("PrivacyGroup.contractAddress", "Returns the deployed contract address from the receipt associated with the transaction. Unset until the transaction is confirmed")
	PrivacyGroupGenesis            = pdm("PrivacyGroup.genesis", "The genesis state data (as stored in the state manager)")
	PrivacyGroupGenesisTransaction = pdm("PrivacyGroup.genesisTransaction", "The ID of the genesis transaction for the privacy group, correlated with the receipt")
	PrivacyGroupGenesisSchema      = pdm("PrivacyGroup.genesisSchema", "The ID of the schema for the genesis state")
	PrivacyGroupGenesisSalt        = pdm("PrivacyGroup.genesisSalt", "The salt used in the genesis state to ensure uniqueness of the resulting state ID")

	PrivacyGroupMessageListenerName      = pdm("PrivacyGroupMessageListener.name", "Unique name for the message listener")
	PrivacyGroupMessageListenerCreated   = pdm("PrivacyGroupMessageListener.created", "Time the listener was created")
	PrivacyGroupMessageListenerStarted   = pdm("PrivacyGroupMessageListener.started", "If the listener is started - can be set to false to disable delivery server-side")
	PrivacyGroupMessageListenerFilters   = pdm("PrivacyGroupMessageListener.filters", "Filters to apply to messages")
	PrivacyGroupMessageListenerOptions   = pdm("PrivacyGroupMessageListener.options", "Options for the receipt listener")
	MessageListenerFiltersSequenceAbove  = pdm("MessageListenerFilters.sequenceAbove", "Only deliver message above a certain sequence (rather than from the earliest message)")
	MessageListenerFiltersDomain         = pdm("MessageListenerFilters.domain", "Only deliver messages for an individual domain")
	MessageListenerFiltersGroup          = pdm("MessageListenerFilters.group", "Only deliver messages for an individual group ID")
	MessageListenerFiltersTopicp         = pdm("MessageListenerFilters.topic", "Regular expression filter to apply to the topic of each message to determine whether to deliver it to the listener")
	MessageListenerOptionsDomainReceipts = pdm("MessageListenerOptions.excludeLocal", "When true, messages sent by the local node will not be delivered to the listener")

	PrivacyGroupMessageID                 = pdm("PrivacyGroupMessage.id", "Unique UUID for each message - will be the same on all nodes that receive the message")
	PrivacyGroupMessageLocalSequence      = pdm("PrivacyGroupMessage.localSequence", "Local sequence number for the message, with the local database of the local node. Will not be the same on all nodes that receive the message")
	PrivacyGroupMessageLocalSent          = pdm("PrivacyGroupMessage.sent", "Time the message was sent. Generated on the sending node")
	PrivacyGroupMessageLocalReceived      = pdm("PrivacyGroupMessage.received", "Time the message was received. Generated by the receiving node (same as sent on the sending node)")
	PrivacyGroupMessageLocalNode          = pdm("PrivacyGroupMessage.node", "The node that originated the message")
	PrivacyGroupMessageLocalCorrelationID = pdm("PrivacyGroupMessage.correlationId", "Optional UUID to designate a message as being in response to a previous message")
	PrivacyGroupMessageLocalDomain        = pdm("PrivacyGroupMessage.domain", "Domain of the privacy group")
	PrivacyGroupMessageLocalGroup         = pdm("PrivacyGroupMessage.group", "Group ID of the privacy group. All members in the group will receive a copy of the message (no guarantee of order)")
	PrivacyGroupMessageTopic              = pdm("PrivacyGroupMessage.topic", "A topic for the message, which by convention should be a dot or slash separated string instructing the receiver how the message should be processed")
	PrivacyGroupMessageData               = pdm("PrivacyGroupMessage.data", "Application defined JSON payload for the message. Can be any JSON type including as an object, array, hex string, other string, or number")
)
